# 1. Настройка конфигурации встроенных виджетов
Пример часто используемой настройки echarts:  
Секция echart Дэши в LuxmsBI отрисовываются с использованием библиотеки Apache Echarts. Для ряда дэшей
существует возможность наследования конфигурационных полей из данной библиотеки. 
Для перехода к настройкам Json – кликаем по дэшу и в настройках выбираем ```JSON config```.

Ниже представлен список команд, которые можно указать в секции echart:
1. Указание ширины и цвета линий дэша:   
```
echart:  {
    series: {
        lineStyle:  {
            color: 'green',
            width: 40,
        },
    },
},
```
2. Указание ширины столцов:
```
    echart: {
        barWidth: 50,
    },
```
3. Указание цвета и размера подписей для оси: 
```
echart: {
    xAxis: {
        axisLabel: {
            textStyle: {
                color: 'gold',
                fontSize: 42,
            },
        },
    },
    yAxis: {
        axisLabel: {
            textStyle: {
                color: 'gold',
                fontSize: 42,
            },
        },
    },
},
```
4. Для изменения варианта отображения точек для дэшей “Линии”, “Области”, “Точки”:
```
echart: {
    series: {
        symbol: 'diamond',
    },
},
```
Подробная документация настроек: [Руководство по конфигурации дэшлетов](https://luxmsbi.com/wp-content/uploads/2024/01/Luxms-BI-dashlet-conf-guide-v9.2.pdf)
# 2. Разработка кастомных дэшей с использованием React и типом визуализации Внутренний. 
Вспомогательный проект bi-magic-resources (BMR) является публичной версией закрытого проекта luxmsbi-web-resources.
Оба проекта по функционалу идентичны и решают одни и те же задачи:  
  * Управлять ресурсами всех атласов, а в общем случае умеет получать в виде файлов
  .json настройки атласа, дешбордов и дешлетов и изменять их прямо в проекте, с последующей выгрузкой на сервер.
  * Использовать git и версионировать разработку.
  * Настроить CI/СD для управления ресурсами на деве, тесте, проде и т.д.
  * Работать над ресурсами проекта командам разработчиков.
  * Позволяет вносить изменения в поведение и внешний вид итогового веб-клиента без
  привлечения devops и backend а лишь силами встроенных методов и скриптов проекта
  BMR и провайдера в лице luxmsbi-web-client
  * Можно массово загружать все ресурсы на сервер (или же только специфических атласов, если требуется), проверяя перед этим, новый ли это файл (т.е. его нужно на сервере
  создать), файл которого больше нет (его надо удалить на сервере), или существующий
  (будет перезаписан).  
  ### Первичная настройка проекта выглядит так:
  * Зайдите на https://github.com/luxms/bi-magic-resources
  * Ознакомьтесь с документацией в https://github.com/luxms/bi-magic-resources#readme
  * Сделайте форк данного проекта в свой github аккаунт и сделайте git clone себе на
  компьютер. Если у вас есть команда - то пусть это лучше сначала форкает тимлид,
  а вы потом клоните его версию, но это опционально. Идея только в том, чтобы вы
  использовали единый репозиторий по понятным причинам.
  * Этот проект создаст необходимое окружение.
  * Запустите ```npm install``` (или ```yarn```, лично мы больше любим его).
  * В корне проекта найдите файл ```config.json``` и добавьте в поле server адрес инстанса
  Luxms BI ("server": "https//mysite.ru/").  
Т.е. тот урл адрес, под которым у вас открываются дашборды, но только до символа “#”. Вот
полный список параметров ```config.json``` из документации (для ленивых): В конфигурацию
входят:  
    * server - http адрес сервера, например "http://project.luxmsbi.com/"  
    * password - пароль для пользователя username  
    * port - порт для запуска локального сервера для npm start  
    * force - выдавать ли предупреждение перед обновлением источника  
    * noRemove - запрещает удалять файлы, если при синхронизации они не найдены  
    * include - регулярное выражение для схем, которые следует включить в сборку перед  
    запуском проекта или отправкой на сервер (^ds_\w+$ по умолчанию)  
    * exclude - регулярное выражение для схем, которые следует исключить из сборки  
    (если например компоненты в указанных атласах не готовы для работы)  
    * kerberos - http адрес сервера для аутентификации kerberos, например  
    HTTP@sso.luxms.
    
Если значения server, username или password нигде не найдены, то их потребуется ввести с клавиатуры.   
По умолчанию в папке src создается папка ds_res (В интерфейсе при выборе файла для виджета она называется Luxms BI Resources).
Создайте в корне проекта файл ```authConfig.json``` с содержим:
```
{
    "master": {
        "username": "ваш логин от BI",
        "password": "ваш пароль"
    }
}
```
Этот файл находится в ```.gitignore``` и нужен для того, чтобы вам не приходилось вводить данные пользователя
каждый раз, когда используете один из скриптов проекта для массовой загрузки/выгрузки ресурсов с сервера 
или старта приложения. P.S. Вы можете, вообще говоря, и указать просто
```
{ 
  "username": "ваш логин",
  "password": "ваш пароль" 
}
```
Но первый способ вам понадобится, когда и если вы будете разрабатывать компоненты, находясь в другой 
ветке проекта. Тогда для каждой ветки нужно указать свою пару логина и пароля. Так можно делать, 
например? когда у вас будут отдельные ветки для дева, теста, прода, каждая из которых имеет свой адрес 
сервера и доступы к нему.  

### Процесс разработки:  
Рассмотрим ваш типичный рабочий процесс в данном проекте на примере.  

Допустим, вам нужно создать совсем новый компонент визуализации, который вы хотите встроить в конкретный дешлет конкретного дешборда у некоего атласа (назовем его ds_51).

У вас есть два способа: через типы визуализации Внешний и Внутренний. Их классы отображения соответсвенно external и internal.  

В первом случае вы пишете хардкорный html с подключением стилей, скриптов, вспомогательной библиотеки bixel.js (подробнее в следующем разделе) или иными библиотеками для визуализации (D3.js например) и разрабатываете с учетом событийной системы, создаваемой данной библиотекой или пишете React компоненты и полностью используете только React-подход.   

Лично мы пропагандируем использование internal как более гибкого способа разработки, плюс таким образом вы получаете по итогу цельное React-приложение + вам доступны ряд методов, которых нет и не может быть в external.  

Допустим, что у вас есть ваши собственные UI-компоненты ,которые будут использоваться в более чем одном компоненте. Вы можете хранить их например в папке src/components с любым деревом папок, которое вам удобно и импортировать в ваш React-компонент, который вы только что создали в папке ds_51.  

Итак: 

1. Укажите адрес сервера в ```config.json```, логин пароль в ```authConfig.json``` 
2. Создайте файлы ```MyComponent.tsx```, ```MyComponent.scss``` и ряд еще каких-то файлов, которые вам понадобятся для разработки на сегодня. Вы выбрали разработку на internal, ибо таков Путь 
3. Перезапустите проект, если он был запущен на момент создания новых файлов , чтобы webpack проекта подхватил ваши файлы и следил за изменениями в дальнейшем. 
4. Откройте localhost с нужным портом, который можно поменять в ```config.json``` в ключе port. 
5. Отправляйтесь в соответствующий атлас, где находится дешлет, в который вы хотите встроить ваш новый компонент. 
Простейший код компонента React ```MyComponent.tsx```, например
```
import React from 'react';
import './MyComponents.scss';

class Test extends React.Component {
    constructor(props) {
        super(props);
    }

    public render() {
        return (
            <div> Hello world</div>
        );
    }
}

export default Test; // обязательно должен содержать export default!
```  

Или функциональный его вариант, без разницы-  
```
import React from 'react';
import './MyComponents.scss';

const Test = (props)
{
    return (
        <div>Hello world</div>
    );
}

export default Test;
```  
6. В режиме редактирования дешборда выберите или создайте нужный дешлет, укажите тип визуализации Внутренний и в блоке Файл выберите MyComponent.js ибо именно в таком виде вы его увидите в списке файлов. Сохраните работу и выйдите из режима редактирования. Уже к этому моменту вы увидите результат рендера вашего компонента. В примере выше это Hello world. Если вы посмотрите на дешлет через инспектор браузера, то никаких фреймов вы не увидите, потому что обвязка посчитает этот компонент нативной частью себя (и будет технически права).
7. Вы разрабатываете компонент в соответствии с бизнес-логикой для него, пишете стили и т.д. Закончили, увидели удовлетворяющий вас результат на локальном сервере и готовитесь залить это в ресурсы на дев стенд и пойти домой под песню Патрика Суэйзи “She’s like the wind”. 
8. Все как обычно при работе с git:
```
git commit -am "Never gonna give you up" 
git pull 
git push
```  
Я бы на всякий случай напомнил вам, что ветку master лучше использовать как финальный результат сборки и мержа иных временных веток (как продакшн). Или новыми ветками задать нужный вам уровень этапов деплоя, который вас устроит, например dev, test, production. Тогда каждый этап последовательно, без пропусков мержится в соответствующую ветку. dev-test, test-prod. Но не dev-prod (только в самых исключительных случаях и понимая, что делаете). Все зависит от того, как устроены процессы вашей разработки в компании. Не бойтесь мержа и ветвления. Просто договоритесь в команде, кто выступает в роли dungeon merge-мастера.  

9. Все, вы сохранили свой прогресс в git. Теперь будем отправлять ресурсы на сервер. Убедитесь, что перед этим, вы сделали ```git pull``` и у вас актуальная версия проекта (ветки) без неразрешенных мерж-конфликтов. 
10. Наберите команду ```yarn push``` (```npm run push```) и увидите, что в консоли идет подключение к серверу, который вы указали в ```config.json``` с логином и паролем из ```authConfig.json```. Затем идет прогрессбар, отражающий этап сравнения вашей версии файлов и того, что на сервере. 
11. Затем вы увидите итоговый диалог, где проект подскажет вам статус файлов и запросит подтверждения на продолжение. Вводите Y и увидите прогрессбар окончательной загрузки ваших ресурсов на сервер.
12. Прогрессбар завершился, ошибок нет. Идите на сервер по “боевому” адресу и проверьте ,что по ссылке на дешборд данного атласа не с локали вы видите тот же функционал, что и на локали. Это значит, что ресурсы корректно залились.

> Перед отправкой ресурсов на сервер через ```yarn push``` (```npm run push```) обязательно делайте ```git pull```. Помните о том, что отправка ресурсов перепишет их контент на тот, что конкретно у вас сейчас в проекте. Потому. работая в команде, вы должны доверять только тому, что есть в git, а не на сервере. Избегайте заливки на сервер файлов, которых нет в git, иначе вы получите расхождение версий файлов и при ближайшем пуше ресурсов просто все удалите. Если вы таки не можете за этим следить, то хотя бы используйте ключ "noRemove": true внутри ```config.json```.

Ибо в скриптах ВMR есть такой хитрый скрипт ```yarn pull``` (```npm run pull```) который стоит использовать очень ограниченно и осторожно, в идеале разово при первичном наполнении ветки проекта или тогда, когда вы указываете в ```config.json``` ключ "dashboards": true, который, при использовании npm run pull позволит вам получить в проекте конфиги дешлетов, дешбордов и датасетов, которые будет храниться в специфических папках, которые у вас автоматически заведутся для каждой папки типа ds_ . Тогда вы сможете хранить конфиги в git и править конфиги этих сущностей так же массово, как вы будете управлять вашими компонентами.  

Этот скрипт ```pull``` сам создаст все папки атласов, которые в данный момент присутствуют на сервере и скачает все файлы и рассортирует их по папкам, включая вложенные. Единственный его минус: он не умеет собирать из .js и .js.map пары итоговый .tsx например. Простим ему) он и не должен, ибо ваши файлы в первую очередь хранятся в git, а не на сервере. Однако вам придется после его работы вручную удалять сбилженные версии ваших компонентов, которые прилетели с сервера, благодаря работе этого скрипта. Благо, что такая операция, как я уже говорил, делается очень редко если не сказать единожды.  

> Вам не обязательно в BMR хранить полный перечень папок с атласами ,которые есть на сервере. Это не нужно. Храните только те, с которыми работает ваша команда сейчас. Те атласы, которые в BMR не присутствуют явно, просто не будут участвовать в итоговом массовой сборке и отправке при команде yarn push. То есть вы можете например создать папку ds_res и в ней хранить ровно тот набор компонентов, который хотите сейчас и не смотреть на ресурсы других атласов. Они останутся нетронутыми.

Подробная документация: [Руководство по кастомизации фронтенда](https://luxmsbi.com/wp-content/uploads/2024/01/Luxms-BI-frontend-customization-v9.2.pdf)  

# 3. Разработка кастомных дэшей с типом визуализации Внешний.

Для добавления кастомного дэша с типом визуализации Внешний:
1. В проекте bi-magic-resources (BMR) получите все изменения проекта с помощью команды ```yarn pull``` или ```npm run pull```
2. Создайте html файл с подключением стилей, скриптов, вспомогательной библиотеки bixel.js (подробнее в следующем разделе) или иными библиотеками для визуализации (D3.js например), так же возможно использование React-подхода.
3. Запустите проект с помощью команды ```yarn start``` или ```npm run start```
4. В режиме редактирования дешборда выберите или создайте нужный дешлет, укажите тип визуализации Внешний и в блоке Файл выберите созданный html-файл.
5. Отправьте изменения в git-репозиторий и на сервер ```yarn push``` или ```npm run push```

# 4. Добавление кастомных react дэшей в конструктор в виде zip архива.

Для отображения кастомного дэша в конструкторе, необходимо открыть атлас, где необходимо использовать кастомный дэш, в режиме редактирования и нажать кнопку “Настроить”.  
 
> В случае, если кнопка отсутствует, то необходимо на вашем сервере в файле /opt/luxmsbi/web/settings/settings.js указать luxStore: "...".

В открывшееся окно перенести архив в формате *.zip с файлами кастомного дэша (ниже описан перечень необходимых файлов для корректного импорта).  
После переноса - дэш автоматически отобразится в списке.  
 
Архив должен содержать следующие элемены: 
1. {dash_name}.js/{dash_name}.js.map - Скомпилированный Typescript/Javacripts файл с логикой дэша; 
2. {dash_name}.css - CSS-файл для стилизации дэша (если необходимо);
3. ```manifest.json``` - JSON-файл, содержащий следующие поля: category - в какой группе дэшей в конструкторе будет содержаться дэш (например “analytic” или “custom”), group - уникальный номер группы дэшей для переключения типа визуализации (например, “111”), title - название дэша, icon - ссылка на иконку дэша. 
4. icon.svg - иконка для отображения в списке визуализаций 
Пример:
```
{
    "category": "analytic",
    "group": "111",
    "title": "BI LABEL",
    "icon": "icon.svg"
}
```
6. ```schema.json``` - JSON-файл, в котором указаны поля, необходимые для корректной настройки дэша в JSON-конфигурации. 
Пример:
```
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "id": "http://json-schema.org/draft-04/schema#",
    "type": "object",
    "properties": {
        "display": {
            "type": "object",
            "properties": {
                "chartColorCategoryA": {
                    "type": "object",
                    "title": "",
                    "properties": {
                        "color": {
                            "type": "string",
                            "title": "Color category A"
                        }
                    }
                }
            }
        }
    }
}
```
8. ui-schema.json - JSON-файл, в котором прописаны поля, отображаемые для данного дэша в конструкторе (Editor). 
Пример:
```
"display": {
    "chartColorCategoryA": {
        "ui:widget": "color"
    },
    "dataSource": {
        "style": {
            "additionalProperties": {
                "additionalProperties": {
                    "color": {
                        "ui:widget": "color"
                    }
                }
            }
        }
    }
}
```
После загрузки архива:
1. Перейти в локальную разработку bi-magic-resources
2. Получить все изменения (в том числе архив) с помощью команды 
```yarn pull``` или ```npm run pull```
3. Подключить виджет из загруженного архива
4. Запушить изменения на сервер с помощью команды 
```yarn push``` или ```npm run push``` для получения изменений на проде

Подробная документация: [Руководство по кастомизации фронтенда](https://luxmsbi.com/wp-content/uploads/2024/01/Luxms-BI-frontend-customization-v9.2.pdf)  
